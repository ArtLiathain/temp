FFEA Viewer {#FFEAviewertut}
=============================

## Installation

The FFEA viewer is available as a plugin for the [PyMOL molecular graphics system](https://www.pymol.org/). It requires Pymol 1.8.x or above, and Python 2.7.x or above.

After installing FFEA, the plugin ` FFEAplugin.tar.gz ` will be found in ` $FFEA_HOME/share/ffea/plugins/pymol `.
 (If that were not the case, the files can be found under the build folder in `/ffeatools/analysis/pymol_plugin`. 
 One would need then to add this folder to a .zip or tar.gz archive).
 In order to install the plugin, 
  open PyMOL, and click 'Plugin' on the top menu bar, then 'Plugin Manager'. Select the 'install new plugin' tab, and click 'choose file'. Then, locate the .tar.gz archive. <!-- You may need to restart PyMOL for the package to load correctly. -->

![Installing the PyMOL viewer plugin](viewer_1_installation.png "Installing the PyMOL viewer plugin")

If you encounter frequent PyMOL crashes or ominous warnings on the console such as `main thread is not in main loop` or `Tcl_AsyncDelete: async handler deleted by the wrong thread`, you may want to install the thread safe version of Tkinter, called [mtTkinter](http://tkinter.unpythonic.net/wiki/mtTkinter). 

## Loading your system

When PyMOL loads, open the 'plugin' menu, and you should see a new option called 'FFEA loader'. This has a file menu that will allow you to select an FFEA script and load the FFEA script file, but before doing that, review the options. Currently, the model needs to be reloaded every time these settings are changed.

![FFEA Viewer settings](viewer_2_settings.png "FFEA Viewer settings")

The FFEA viewer settings are:
* System name: abtitrary, used to identify the system in the PyMOL sidebar.
* Display: displays spring objects and pinned nodes if checked.
* Show solid:
  * Plain solid renders the mesh in flat colours.
  * Material colours the mesh different depending on a user-selectable material parameter.
  * No solid does not display a solid mesh.
* Show Mesh:
  * Surface mesh renders a wireframe of the surface
  * Whole mesh renders a wireframe that includes the internal elements
  * No mesh does not display a wireframe mesh.
* Indices:
  * Node Indices displays the indices of all the nodes, including the 2nd-order elements.
  * Node Indices (Linear) only displays the indices of the linear elements. In most cases, this is more useful, as displaying second-order nodes can make the image hard to read.
  * Element indices displays the indices of the elements.
  * Face indices displays the indices of the faces (surface elements) only.
  * No indices does not display indices.
  * Clicking the 'add node psuedoatoms' button after the simulation is loaded will cause PyMOL to load a psuedoatom at the location of each node. Psuedoatoms can be targeted by all of PyMOL's regular analysis tools. For example, you can type `label all, name` into the PyMOL console.
* Show Box:
  * Simulation box outline draws an outline of the simulation box - the simulation box is the volume which objects in the simulation can occupy.
  * Simulation box (whole) draws the entire box.
* Loading type:
  * Load trajectory is the loading type to use if you have a finished trajectory (.out file) that has been generated by the runner. It will load each frame of the trajectory into PyMOL. If the trajectory is not found the system will be loaded (into box).
  * Load system (into box) will load the starting state of the system, and it will show how the system will be initialised relative to the box. It can be used to check the size of your molecule(s) compared to the simulation box and check that their position is correct.
  * Load system (plainly) will load the system plainly, using the same coordinates that appear in the `.node` file.
  Depending on the way the models have been generated, 
  this may be the best way to visualise the models before starting the simulation. This is specially useful when 
  checking that the model has been set up correctly, as one can load the FFEA system alongside a (number of) PDB file(s),
  thus checking that both share origin and scale.
  * CGO will load the trajectory and cache the calls to PyMOL's API directly to the hard drive. This results in a slower initial load, but faster subsequent loads.
* Highlight Nodes:
  * Provide a list of nodes, e.g. '1, 2, 3' (no quotes) and the a separate blob will be created using only those nodes. Useful for tracking down element inversions. Warning: right now, this only works with CGO trajectories.
  

## Viewing models

![FFEA viewer interface](viewer_3_interface.png "FFEA viewer interface")

The PyMOL viewer interface is relatively straightforward. A list of loaded objects appears on the right-hand side. The 'action' menu (A) allows you to rename, center and delete objects. The S, H and L menus let you show, hide and label elements that only appear on other formats. The C button allows you to recolour the object. Clicking on the objects name shows and hides that object. At the bottom-right, there are camera controls, and playback controls.

## Exporting images and videos

To export a still image, click the file menu, and click 'Save Image As. For higher-quality images, you may wish to resize the viewport, as images are exported at the same resolution they are displayed  Also consider right-clicking the viewing area and clicking 'ray', which will generate a (higher-quality) raytraced frame.

PyMOL does not export videos by default, although installing the FreeMOL addons and an MPEG encoder will all you to do so.

To get higher-quality videos in a more modern format, select File>Save Movie As>PNG Images. This will save each frame as a still image, organized by filename. For example, saving with the filename 'test' for a 100-frame trajectory will produce 100 PNG files, called `test0001.png` to `test0100.png`.

To stitch these together into a video, you can use ffmpeg, a command-line tool. Install ffmpeg and call it using the following arguments:

	ffmpeg -r 60 -i name%04d.png -c:v libx264 -pix_fmt yuv420p -vf "scale=trunc(iw/2)*2:trunc(ih/2)*2" out.mp4

The arguments are
* `-r`, the framerate
* `-i`, the input. The `%04d` means that FFMpeg will compile together any frames matching that format (e.g. `name0001.png`, `name0002.png`).
* `-c:v`, the codec
* `-pix_fmt`, the pixel format
* -`vf`, user-configurable filter. PyMOL can often output files with very awkward dimensions, which are hard to encode - this filter fixes that.

Finally, the output filename is a positional argument.

## Converting FFEA trajectories back to atomistic data

If the data in our original PDB file and our final trajectory file is aligned correctly, then we can map our FFEA trajectory back onto the original PDB. Although we have not done anything to misalign our final FFEA mesh from our EM density map, there is no guarantee that our EM density map is aligned with our PDB file.

The first thing to do is to open both the PDB and EM density map in UCSF Chimera. 

![The PDB and EM density map are misalgined](structuremap1.png "The PDB and EM density map are misalgined")

If they are not aligned, select 'tools' on the volume viewer menu bar, and select 'Fit in map' and push 'fit'. If nothing happens (as it didn't, in our example) you may need to give the algorithm some help. On the main UCSF Chimera window, select 'movement' and 'movement mouse mode'. Select 'move molecule' from the dropdown menu, and use the middle mouse button to drag the PDB object over the electron density map. Then, use the left mouse button to rotate the PDB into the approximate correct position. Push 'fit' on the 'Fit in Map' window to finish the job.

![Aligned PDB and EM density map](structuremap2.png "Aligned PDB and EM density map")

The new PDB can be saved by opening the file menu and selecting 'save PDB'. For this example, we will save it as '4hel_fit.pdb'.

The next step is to create the map between the PDB structure and FFEA structure. To do this, run the following command from the terminal:


	ffeatools makestructuremap -i emd_5043_10ang.node -t emd_5043_10ang.top -o 4hel_fit.pdb -m GroELFFEAtoPDB.map -scale 1.0


This will use the .node and .top files from before, and the .pdb file you just made, to create a .map file. We then run


	ffeatools maptosparse GroELFFEAtoPDB.map  GroELFFEAtoPDB_sparse.map


This conversts our map into a sparse matrix. Finally, we apply the map by running


	ffeatools maptraj emd_5043_10ang_trajectory.ftj emd_5043_10ang_trajectory.pdb GroELFFEAtoPDB_sparse.map 4hel_fit.pdb


This script will create the file specified by the second positional argument, in this case `emd_5043_10ang_trajectory.pdb`. This file can be opened in a visualisation program such as PyMOL or VMD.
