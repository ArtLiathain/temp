# -*- coding: utf-8 -*-
# 
#  This file is part of the FFEA simulation package
#  
#  Copyright (c) by the Theory and Development FFEA teams,
#  as they appear in the README.md file. 
# 
#  FFEA is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
# 
#  FFEA is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
# 
#  You should have received a copy of the GNU General Public License
#  along with FFEA.  If not, see <http://www.gnu.org/licenses/>.
# 
#  To help us fund FFEA development, we humbly ask that you cite 
#  the research papers on the package.
#

import sys
sys.path.insert(0, '/home/rob/software/ffea/ffeatools/FFEA_analysis/FFEA_meas_tools/')

import slender_analysis_lib
import FFEA_rod
import copy
import numpy as np
import matplotlib.pyplot as plt
import global_plot_params

def setrc():
    global_plot_params.setrc(plt)

def normalize_hist(bins, values):
    area = float(np.sum(values))
    values = values/area
    return bins, values, area

experimental_angles = np.array([5,5,5,5,5,5,5,5,5,15,15,15,15,15,15,15,15,15,25,25,25,25,25,25,25,25,25,35,35,35,35,35,35,35,45,45,45,45,45,55,55,55,55,55,55,55,65,65,65,65,65,65,65,65,75,75,75,75,75,85,85,85,85,85,85,85,85,85,95,95,95,95,95,95,95,105,105,105,105,115,115,115,115])
#https://www.ncbi.nlm.nih.gov/pmc/articles/PMC2640231/figure/F4/

def get_hinge_bend_angles(rod, hinge1_index, hinge2_index, start_index = 0, end_index = -1):
    """
    For a rod containing a hinge, compute the hinge angle for every frame of
    the trajectory.
    Parameters:
        rod - an instance of FFEA_rod.FFEA_rod
        hinge1_index, hinge2_index - indices of the nodes on either side
        of the hinge. Can be the same, but I wouldn't.
        start_index, end_index - default to the ends of the rod, but can be
        moved further up the rod.
    Returns:
        angles, a 1-d array containing all the angles the bend has taken, in
        degrees.
    """
    angles = np.zeros(len(rod.current_r))
    
    for frame_index in range(len(angles)):
        start = copy.copy(rod.current_r[frame_index][start_index])
        end = copy.copy(rod.current_r[frame_index][end_index])
        hinge1 = copy.copy(rod.current_r[frame_index][hinge1_index])
        hinge2 = copy.copy(rod.current_r[frame_index][hinge2_index])
        
        for node_pos in [start, end, hinge1, hinge2]:
            #node_pos = slender_analysis_lib.transform_point(node_pos, start, end)
            node_pos = slender_analysis_lib.transform_point_two_vectors(node_pos, start, hinge1, hinge2, end)
        
        before_hinge = FFEA_rod.rod_math.normalize(hinge1 - start)
        after_hinge = FFEA_rod.rod_math.normalize(end - hinge2)
        
        angles[frame_index] = slender_analysis_lib.get_angle_between_vectors(before_hinge, after_hinge)
        
    return np.rad2deg(angles)

def get_angle_distribution(angles, bins=18, bin_range=(0,180), allow_negative = False, scatter_plot_mode = False):
    """
    For a list of angles generated by get_hinge_bend_angles, this generates
    a histogram of angles.
    Parameters:
        angles, a 1-d array listing all the angles the hinge has taken
        bins, the number of bins
        bin_range, the range the bins are over
        allow_negative - if true, negative values are allowed. If not, the
        absolute value is used.
        scatter_plot_mode - if True, shifts some of the data and adjusts
        the axis so that the result can be plotted as a line graph or
        scatter plot.
    Returns:
        bins, values, two 1-d numpy arrays. If scatter_plot_mode is false,
        these are at the edges of bins, if not they are at the middle. The
        values are the frequency.
    """
    if not allow_negative:
        angles = abs(angles)
    values, bins = np.histogram(angles, bins=bins, range=bin_range)
    if scatter_plot_mode:
        bin_width = (bins[1] - bins[0])
        bins = bins+(bin_width/2.)
        bins = bins[:-1]
    return bins, values

def get_angle_distribution_err(angles, bins=18, bin_range=(0,180), allow_negative = False, scatter_plot_mode = False):
    half_point = int(len(angles)/2)
    first_half = angles[:half_point]
    second_half = angles[half_point:]
    first_dist_bins, first_dist_values = get_angle_distribution(first_half, bins, bin_range, allow_negative, scatter_plot_mode)
    second_dist_bins, second_dist_values = get_angle_distribution(second_half, bins, bin_range, allow_negative, scatter_plot_mode)
    return np.abs(first_dist_values - second_dist_values)


def plot_angle_distribution(bin_list, value_list, label_list, ticktype_list, filename="angle_distribution_err.pdf", norm=True, xlabel="Kink angle ($^\circ$)", errors=None):
    """
    For a set of bins and values generated by get_angle_distrubution in
    scatter plot mode, this will generate a line graph showing the distrubution
    of angles.
    Parametesr:
        bin_list, value_list, label_list, ticktype_list: lists containing bins,
        values, labels and ticktypes. By that I mean a list of bin arrays, a
        list of value arrays, a list of strings to use as labels for those
        bin and value arrays, and a list of matplotlib linestyles (strings).
        filename: the filename to save. A string.
        norm: whether to normalize the plot or not (bool).
    No return values.
    """
    new_value_list = []
    if errors:
        new_err_list = []
    
    if norm:
        for values in range(len(value_list)):
            scaled_bins, scaled_values, scale_factor = normalize_hist(bin_list[values], value_list[values])
            new_value_list.append( scaled_values )
            if errors:
                if type(errors[values]) != type(None):
                    new_err_list.append(errors[values]/scale_factor)
                else:
                    new_err_list.append(None)
            #new_value_list.append( value_list[values].astype(float)/float(np.max(value_list[values]))  )
    else:
        for values in range(len(value_list)):
            new_value_list.append( value_list[values].astype(float)  )
            if errors:
                if type(errors[values]) != type(None):
                    new_err_list.append(errors[values])
                else:
                    new_err_list.append(None)
    
    with plt.style.context("fast"):
        setrc()
        if not errors:
            for item_no in range(len(bin_list)):
                plt.plot(bin_list[item_no], new_value_list[item_no], linestyle=ticktype_list[item_no], label=label_list[item_no])
        if errors:
            for error in range(len(new_err_list)):
                if type(new_err_list[error]) != type(None):
                    plt.errorbar(bin_list[error], new_value_list[error], yerr=new_err_list[error], linestyle=ticktype_list[error], label=label_list[error])
                else:
                    plt.plot(bin_list[error], new_value_list[error], linestyle=ticktype_list[error], label=label_list[error])
        plt.xlabel(xlabel)
        plt.ylabel("Normalized occupancy")
        legend = plt.legend(loc='upper right', frameon=False)
        plt.tight_layout()
        plt.savefig(filename, dpi=300)
        plt.clf()
    return

def auto(error=True):
    """
    This generates the figures seen in the paper 'An elastic Cosserat rod
    algorithm for slender biological objects, validated using the NDC80 protein
    complex (working title)."
    """
    source_rod = FFEA_rod.FFEA_rod("/home/rob/pCloudSync/Notebooks/FFEA/Rods_Publication_1/datums/structure/source.rodtraj")
    destination_rod = FFEA_rod.FFEA_rod("/home/rob/pCloudSync/Notebooks/FFEA/Rods_Publication_1/datums/iter1/dest.rodtraj")
    source_angles = get_hinge_bend_angles(source_rod, 4, 9, end_index=-2)
    destination_angles = get_hinge_bend_angles(destination_rod, 4, 9, end_index=-2)
    source_bins, source_values = get_angle_distribution(source_angles, scatter_plot_mode = True)
    destination_bins, destination_values = get_angle_distribution(destination_angles, scatter_plot_mode = True)
    experimental_bins, experimental_values = get_angle_distribution(experimental_angles, scatter_plot_mode = True)
    source_err = get_angle_distribution_err(source_angles, scatter_plot_mode = True)
    destination_err = get_angle_distribution_err(destination_angles, scatter_plot_mode = True)
    plot_angle_distribution([source_bins, destination_bins, experimental_bins], [source_values, destination_values, experimental_values], ["Atomistic MD with AMBER", "Elastic rod simulation", "Experimental data"], ["-", "--", "-."], errors=[source_err, destination_err, None])
